<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
@license https://github.com/t2ym/thin-hook/blob/master/LICENSE.md
Copyright (c) 2017, Tetsuya Mori <t2y3141592@gmail.com>. All rights reserved.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="../../thin-hook/hook.min.js?version=25&sw-root=/&no-hook=true&hook-name=__hook__&context-generator-name=method2&fallback-page=index-fb.html&service-worker-ready=false"></script></head></html><!--
  <script context-generator no-hook>
  {
    hook.contextGenerators.method2 = function generateMethodContext2(astPath) {
      return astPath.map(([ path, node ], index) => node && node.type
        ? (node.id && node.id.name ? node.id.name : (node.key && node.key.name
          ? (node.kind === 'get' || node.kind === 'set' ? node.kind + ' ' : node.static ? 'static ' : '') + node.key.name : ''))
        : index === 0 ? path : '').filter(p => p).join(',') +
          (astPath[astPath.length - 1][1].range ? ':' + astPath[astPath.length - 1][1].range[0] + '-' + astPath[astPath.length - 1][1].range[1] : '');
    }
    Object.freeze(hook.contextGenerators);
  }
  </script>
  <script no-hook>
    var callTree = [['Phrases']];
    var callTreeLastLength = callTree.length;
    var counter = 0;
    var calleeErrorCounter = 0;
    var log = [];
    var contexts = {};
    var locationContexts = {};
    var contextTransitions = {};
    var contextReverseTransitions = {};
    var lastContext;
    var contextStack = [];
    var contextStackLog = {};
    var callbacks = {};
    var reverseCallbacks = {};
    var pseudoContextArgument = Symbol('callback context');
    var callbackFunctions = new WeakMap();
    window.__hook__ = function __hook__(f, thisArg, args, context, newTarget) {
      counter++;
      if (args[0] === pseudoContextArgument) {
        return context;
      }
      let _lastContext = lastContext;
      contexts[context] = true;
      if ((context === 'setTimeout' || context === 'setInterval' || context.indexOf('Promise') === 0 || context === 'EventTarget,addEventListener') && args) {
        for(let i = 0; i < 2; i++) {
          if (typeof args[i] === 'function') {
            let cbContext = callbackFunctions.get(args[i]);
            if (typeof cbContext === 'undefined') {
              cbContext = args[i].toString().indexOf('__hook__') >= 0;
              if (cbContext) {
                cbContext = args[i](pseudoContextArgument);
              }
              callbackFunctions.set(args[i], cbContext);
            }
            if (cbContext) {
              reverseCallbacks[lastContext] = reverseCallbacks[lastContext] || {};
              reverseCallbacks[lastContext][context] = reverseCallbacks[lastContext][context] || {};
              reverseCallbacks[lastContext][context][cbContext] = args[i];
              callbacks[cbContext] = callbacks[cbContext] || {};
              callbacks[cbContext][context] = callbacks[cbContext][context] || {};
              callbacks[cbContext][context][lastContext] = args[i];
              //console.log('Registering CALLBACK ' + lastContext + ' -> ' + context + ' -> callback ' + hfContext, args[i]);
            }
          }
        }
      }
      lastContext = context;
      contextStack.push(context);
      //contextStackLog[contextStack.join(' -> ')] = true;
      contextTransitions[_lastContext] = contextTransitions[_lastContext] || {};
      contextTransitions[_lastContext][context] = true;
      contextReverseTransitions[context] = contextReverseTransitions[context] || {};
      contextReverseTransitions[context][_lastContext] = true;

      if (callbacks[context]) {
        let c = 0;
        for (let asyncEventContext in callbacks[context]) {
          for (let callerContext in callbacks[context][asyncEventContext]) {
            c++;
            console.log('Async CALLBACK ' + callerContext + ' -> ' + asyncEventContext + ' -> ' + context);
          }
        }
        if (c !== 1) {
          console.log('CALLBACK with possibility of ' + c + ' multiple callers for ' + context);
        }
      }

      let result = newTarget ? Reflect.construct(f, args) : thisArg ? f.apply(thisArg, args) : f(...args);
      lastContext = _lastContext;
      // if (contextStack[contextStack.length - 1] !== context) { debugger; }
      contextStack.pop();
      return result;
    }

    function showContextStackLog() {
      let asyncCalls = Object.keys(contextStackLog).filter(c => c.match(/(setTimeout|setInterval|Promise)/g));
      console.log(asyncCalls);
    }
    {
      _native = {
        Promise: Promise
      }
      _nativeMethods = {
        Promise: {
          static: {
            resolve: Promise.resolve,
            reject: Promise.reject,
            all: Promise.all,
            race: Promise.race
          },
          proto: {
            then: Promise.prototype.then,
            catch: Promise.prototype.catch
          }
        },
        EventTarget: {
          static: {},
          proto: {
            addEventListener: EventTarget.prototype.addEventListener
          }
        },
        setTimeout: setTimeout,
        setInterval: setInterval
      }

      function hookPromise(hookName) {
        let _Promise = function Promise(...args) {
          return window[hookName](_native.Promise, null, args, 'Promise', new.target);
        };

        [ 'resolve', 'reject', 'all', 'race', 'prototype' ].forEach(prop => {
          _Promise[prop] = Promise[prop];
        });

        _Promise.prototype.then = function (...args) {
          return __hook__(_nativeMethods.Promise.proto.then, this, args, 'Promise,then');
        }

        _Promise.prototype.catch = function (...args) {
          return __hook__(_nativeMethods.Promise.proto.catch, this, args, 'Promise,catch');
        }
        return _Promise;                
      }

      window.Promise = hookPromise('__hook__');

      window.setTimeout = function setTimeout(...args) {
        return window.__hook__(_nativeMethods.setTimeout, this, args, 'setTimeout');
      }

      window.setInterval = function setInterval(...args) {
        return window.__hook__(_nativeMethods.setInterval, this, args, 'setInterval');
      }

      EventTarget.prototype.addEventListener = function addEventListener(...args) {
        return window.__hook__(_nativeMethods.EventTarget.proto.addEventListener, this, args, 'EventTarget,addEventListener');
      }

    }
  </script>
  <script no-hook>
    hook.hook(hook.Function('__hook__', [['Function', {}]]));
  </script>

  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <title>thin-hook Demo</title>

  <meta name="theme-color" content="#fff">

  <script>

    // setup Polymer options
    window.Polymer = {lazyRegister: true, dom: 'shadow'};

    // load webcomponents polyfills
    (function() {
      if ('registerElement' in document
          && 'import' in document.createElement('link')
          && 'content' in document.createElement('template')) {
        // browser has web components
      } else {
        // polyfill web components
        var e = document.createElement('script');
        e.src = '../../webcomponentsjs/webcomponents-lite.min.js';
        document.head.appendChild(e);
      }
    })();

  </script>

  <link rel="import" href="../../live-localizer/live-localizer-lazy.html">
  <link rel="import" href="my-app.html">

  <style>

    body {
      margin: 0;
      font-family: 'Roboto', 'Noto', sans-serif;
      line-height: 1.5;
      min-height: 100vh;
      background-color: #eee;
    }

  </style>

</head>
<body>

  <my-app></my-app>

  <live-localizer>
    <C!--
      Firebase storage for Live Localizer

      Minimum ad-hoc security rules for Firebase storage (to be updated for role-based security and user management):

      // Each user can access one's own data only.
      {
        "rules": {
          "users": {
            "$uid": {
              ".read": "$uid === auth.uid",
              ".write": "$uid === auth.uid"
            }
          }
        }
      }
    --C>
    <live-localizer-firebase-storage id="firebase-storage" class="storage cloud"
      auth-provider="google"
      auth-domain="live-localizer-demo.firebaseapp.com"
      database-url="https://live-localizer-demo.firebaseio.com"
      api-key="AIzaSyCjrlPhl0cLSZVRsDvuajq16vkerhcu_UM">
    </live-localizer-firebase-storage>
  </live-localizer>
</body>
</html>
-->