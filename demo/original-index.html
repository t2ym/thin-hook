<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
@license https://github.com/t2ym/thin-hook/blob/master/LICENSE.md
Copyright (c) 2017, Tetsuya Mori <t2y3141592@gmail.com>. All rights reserved.
-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="../../thin-hook/hook.min.js?version=111&sw-root=/&no-hook=true&hook-name=__hook__&context-generator-name=method2&fallback-page=index-fb.html&service-worker-ready=true"></script>
  <script context-generator src="hash-context-generator.js?no-hook=true"></script>
  <script context-generator no-hook>
  {
    hook.parameters.cors = [
      'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js',
      (url) => { let _url = new URL(url); return _url.hostname !== location.hostname && ['www.gstatic.com'].indexOf(_url.hostname) < 0; }
    ];
    hook.contextGenerators.method2 = function generateMethodContext2(astPath) {
      return astPath.map(([ path, node ], index) => node && node.type
        ? (node.id && node.id.name ? node.id.name : (node.key && node.key.name
          ? (node.kind === 'get' || node.kind === 'set' ? node.kind + ' ' : node.static ? 'static ' : '') + node.key.name : ''))
        : index === 0 ? path : '').filter(p => p).join(',') +
          (astPath[astPath.length - 1][1].range ? ':' + astPath[astPath.length - 1][1].range[0] + '-' + astPath[astPath.length - 1][1].range[1] : '');
    }
    Object.freeze(hook.contextGenerators);
  }
  </script>
  <script no-hook>
    var callTree = [['Phrases']];
    var callTreeLastLength = callTree.length;
    var counter = 0;
    var calleeErrorCounter = 0;
    var log = [];
    var contexts = {};
    var locationContexts = {};
    var contextTransitions = {};
    var contextReverseTransitions = {};
    var lastContext;
    var contextStack = [];
    var contextStackLog = {};
    var callbacks = {};
    var reverseCallbacks = {};
    var pseudoContextArgument = Symbol('callback context');
    var callbackFunctions = new WeakMap();
    window.__hook__ = function __hook__(f, thisArg, args, context, newTarget) {
      counter++;
      if (args[0] === pseudoContextArgument) {
        return context;
      }
      let _lastContext = lastContext;
      contexts[context] = true;
      if ((context === 'setTimeout' || context === 'setInterval' || context.indexOf('Promise') === 0 || context === 'EventTarget,addEventListener') && args) {
        for(let i = 0; i < 2; i++) {
          if (typeof args[i] === 'function') {
            let cbContext = callbackFunctions.get(args[i]);
            if (typeof cbContext === 'undefined') {
              cbContext = args[i].toString().indexOf('__hook__') >= 0;
              if (cbContext) {
                cbContext = args[i](pseudoContextArgument);
              }
              callbackFunctions.set(args[i], cbContext);
            }
            if (cbContext) {
              reverseCallbacks[lastContext] = reverseCallbacks[lastContext] || {};
              reverseCallbacks[lastContext][context] = reverseCallbacks[lastContext][context] || {};
              reverseCallbacks[lastContext][context][cbContext] = args[i];
              callbacks[cbContext] = callbacks[cbContext] || {};
              callbacks[cbContext][context] = callbacks[cbContext][context] || {};
              callbacks[cbContext][context][lastContext] = args[i];
              //console.log('Registering CALLBACK ' + lastContext + ' -> ' + context + ' -> callback ' + cbContext, args[i]);
            }
          }
          else if (i === 0 && (context === 'setTimeout' || context === 'setInterval') && typeof args[i] === 'string') {
            let lines = args[i].split(/\n/);
            let match = lines[lines.length - 1].match(/}, this, args, '([^']*)'\)\)\)\(\);/);
            if (match) {
              let cbContext = match[1];
              reverseCallbacks[lastContext] = reverseCallbacks[lastContext] || {};
              reverseCallbacks[lastContext][context] = reverseCallbacks[lastContext][context] || {};
              reverseCallbacks[lastContext][context][cbContext] = args[i];
              callbacks[cbContext] = callbacks[cbContext] || {};
              callbacks[cbContext][context] = callbacks[cbContext][context] || {};
              callbacks[cbContext][context][lastContext] = args[i];
              //console.log('Registering CALLBACK script ' + lastContext + ' -> ' + context + ' -> callback script ' + cbContext, args[i]);
            }
          }
        }
      }
      lastContext = context;
      contextStack.push(context);
      //contextStackLog[contextStack.join(' -> ')] = true;
      contextTransitions[_lastContext] = contextTransitions[_lastContext] || {};
      contextTransitions[_lastContext][context] = true;
      contextReverseTransitions[context] = contextReverseTransitions[context] || {};
      contextReverseTransitions[context][_lastContext] = true;

      if (callbacks[context]) {
        let c = 0;
        for (let asyncEventContext in callbacks[context]) {
          for (let callerContext in callbacks[context][asyncEventContext]) {
            c++;
            //console.log('Async CALLBACK ' + callerContext + ' -> ' + asyncEventContext + ' -> ' + context);
          }
        }
        if (c !== 1) {
          //console.log('CALLBACK with possibility of ' + c + ' multiple callers for ' + context);
        }
      }

      let result = newTarget ? Reflect.construct(f, args) : thisArg ? f.apply(thisArg, args) : f(...args);
      lastContext = _lastContext;
      // if (contextStack[contextStack.length - 1] !== context) { debugger; }
      contextStack.pop();
      return result;
    }

    function showContextStackLog() {
      let asyncCalls = Object.keys(contextStackLog).filter(c => c.match(/(setTimeout|setInterval|Promise)/g));
      console.log(asyncCalls);
    }
    {
      _native = {
        Promise: Promise,
        HTMLScriptElement: typeof HTMLScriptElement === 'function' ? HTMLScriptElement : undefined,
        Node: typeof Node === 'function' ? Node : undefined,
        Element: typeof Element === 'function' ? Element : undefined
      }
      _nativeMethods = {
        Promise: {
          static: {
            resolve: Promise.resolve,
            reject: Promise.reject,
            all: Promise.all,
            race: Promise.race
          },
          proto: {
            then: Promise.prototype.then,
            catch: Promise.prototype.catch
          }
        },
        EventTarget: {
          static: {},
          proto: {
            addEventListener: EventTarget.prototype.addEventListener
          }
        }
      }
      let contextGeneratorName = 'method2';

      function hookPromise(hookName) {
        let _Promise = function Promise(...args) {
          return window[hookName](_native.Promise, null, args, 'Promise', new.target);
        };

        [ 'resolve', 'reject', 'all', 'race', 'prototype' ].forEach(prop => {
          _Promise[prop] = Promise[prop];
        });

        _Promise.prototype.then = function (...args) {
          return window[hookName](_nativeMethods.Promise.proto.then, this, args, 'Promise,then');
        }

        _Promise.prototype.catch = function (...args) {
          return window[hookName](_nativeMethods.Promise.proto.catch, this, args, 'Promise,catch');
        }
        return _Promise;                
      }

      window.Promise = hookPromise('__hook__');

      EventTarget.prototype.addEventListener = function addEventListener(...args) {
        return window.__hook__(_nativeMethods.EventTarget.proto.addEventListener, this, args, 'EventTarget,addEventListener');
      }
    }
  </script>
  <script no-hook>
    [ 'Function', 'setTimeout', 'setInterval', 'Node', 'Element', 'HTMLScriptElement', 'HTMLAnchorElement', 'HTMLAreaElement', 'Document' ]
      .forEach((name) => hook.hook(hook[name]('__hook__', [[name, {}]], 'method2')));
  </script>
  <script>
    {
      setTimeout('console.log("callback script in string called")', 1000);
      setTimeout(() => console.log("callback script called"), 1000);
      window.__intervalId = setInterval('console.log("callback script in string called. intervalId = ", __intervalId); clearInterval(__intervalId)', 1000);
    }
    {
      let script = document.createElement('script');
      script.textContent = 'console.log("set textContent of HTMLScriptElement")';
      addEventListener('load', function onLoad(event) {
        removeEventListener('load', onLoad);
        document.body.appendChild(script);
      });
    }
    {
      let script = document.createElement('script');
      script.text = 'console.log("set type attribute of text/x-script")';
      script.setAttribute('type', 'text/x-script');
      script.setAttribute('type', 'text/javascript');
      addEventListener('load', function onLoad(event) {
        removeEventListener('load', onLoad);
        document.body.appendChild(script);
      });
    }
    {
      let script = document.createElement('script');
      script.text = 'console.log("set type property of text/xx-script")';
      script.type = 'text/xx-script';
      script.type = 'text/javascript';
      addEventListener('load', function onLoad(event) {
        removeEventListener('load', onLoad);
        document.body.appendChild(script);
      });
    }
    {
      let anchor = document.createElement('a');
      anchor.setAttribute('href', '.');
      anchor.setAttribute('href', 'javascript:console.log("set href attribute of anchor element")');
      console.log('a.href = ' + anchor.getAttribute('href'));
    }
    {
      let div = document.createElement('div');
      div.setAttribute('onclick', 'console.log("set onclick attribute of div element", event.type)');
      console.log('div.onclick = ' + div.getAttribute('onclick'));
      addEventListener('load', function onLoad(event) {
        removeEventListener('load', onLoad);
        document.body.appendChild(div);
        div.click();
      });
    }
    {
      let anchor = document.createElement('a');
      anchor.href = '.';
      anchor.href = 'javascript:console.log("set href property of anchor element")';
      console.log('a.href = ' + anchor.href);
    }
    {
      let area = document.createElement('area');
      area.href = '.';
      area.href = 'javascript:console.log("set href property of area element")';
      console.log('area.href = ' + area.href);
    }
    {
      document.write('<sc' + 'ript>' + '(function write1() { console.log("script tag via document.write"); })()' + '</sc' + 'ript>');
      document.write('<sc' + 'ript src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js?cors=true"></sc' + 'ript>');
      document.write('<sc' + 'ript no-hook>' + '(function write2() { console.log("no-hook script tag via document.write"); })()' + '</sc' + 'ript>');
      document.write('<div><sc' + 'ript>' + '(function write3() { console.log("script tag in div tag via document.write"); })()' + '</sc' + 'ript></div>');
      document.write('<div><sc' + 'ript no-hook>' + '(function write4() { console.log("no-hook script tag in div tag via document.write"); })()' + '</sc' + 'ript></div>');
      document.write('<div></div>');
    }
  </script>
  <!-- CORS scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jsSHA/2.2.0/sha.js?cors=true"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.min.js"></script>

  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

  <title>thin-hook Demo</title>

  <meta name="theme-color" content="#fff">

  <script>

    // setup Polymer options
    window.Polymer = {lazyRegister: true, dom: 'shadow'};

    // load webcomponents polyfills
    (function() {
      if ('registerElement' in document
          && 'import' in document.createElement('link')
          && 'content' in document.createElement('template')) {
        // browser has web components
      } else {
        // polyfill web components
        var e = document.createElement('script');
        e.src = '../../webcomponentsjs/webcomponents-lite.min.js';
        document.head.appendChild(e);
      }
    })();

  </script>

  <link rel="import" href="../../live-localizer/live-localizer-lazy.html">
  <link rel="import" href="my-app.html">

  <style>

    body {
      margin: 0;
      font-family: 'Roboto', 'Noto', sans-serif;
      line-height: 1.5;
      min-height: 100vh;
      background-color: #eee;
    }

  </style>

</head>
<body>

  <my-app></my-app>

  <live-localizer>
    <!--
      Firebase storage for Live Localizer

      Minimum ad-hoc security rules for Firebase storage (to be updated for role-based security and user management):

      // Each user can access one's own data only.
      {
        "rules": {
          "users": {
            "$uid": {
              ".read": "$uid === auth.uid",
              ".write": "$uid === auth.uid"
            }
          }
        }
      }
    -->
    <live-localizer-firebase-storage id="firebase-storage" class="storage cloud"
      auth-provider="google"
      auth-domain="live-localizer-demo.firebaseapp.com"
      database-url="https://live-localizer-demo.firebaseio.com"
      api-key="AIzaSyCjrlPhl0cLSZVRsDvuajq16vkerhcu_UM">
    </live-localizer-firebase-storage>
  </live-localizer>
</body>
</html>
